% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pam.sim_data.R
\name{sim_cox_weibull_censored}
\alias{sim_cox_weibull_censored}
\title{Simulate Cox survival data with targeted (or fixed) censoring}
\usage{
sim_cox_weibull_censored(n, pi_c, v, beta, mu = NULL, sd = NULL, seed = NULL)
}
\arguments{
\item{n}{Integer. Number of individuals.}

\item{pi_c}{Numeric in \eqn{[0, 0.99]}. Target censoring proportion. Ignored if both
\code{mu} and \code{sd} are provided (since no calibration is done).}

\item{v}{Positive numeric. Weibull shape in \eqn{H_0(t) = (0.5 t)^v}.}

\item{beta}{Numeric vector of regression coefficients; length defines \eqn{p}.
Each covariate is \eqn{X_j = 10 \cdot \mathrm{Bernoulli}(0.5)}.}

\item{mu}{Optional numeric. Mean of \eqn{\log C}. If supplied with \code{sd}, no
calibration is performed.}

\item{sd}{Optional positive numeric. Standard deviation used for \eqn{r_i} in
\eqn{\log C = \mu + r_i}. If \code{NULL}, defaults to \eqn{\mathrm{sd}(\log Y)}.}

\item{seed}{Optional integer seed for reproducibility.}
}
\value{
A \code{data.frame} with columns:
\itemize{
  \item \code{time}: observed time \eqn{T_i = \min(Y_i, C_i)}.
  \item \code{status}: event indicator \eqn{1\{Y_i \le C_i\}}.
  \item \code{x1, x2, ...}: generated covariates.
  \item \code{y_true}: latent event time \eqn{Y_i}.
  \item \code{cens_time}: censoring time \eqn{C_i}.
}
Attributes include:
\itemize{
  \item \code{mu}: censoring shift used.
  \item \code{sd_log}: sd used for \eqn{r_i} in \eqn{\log C}.
  \item \code{sd_logY}: \eqn{\mathrm{sd}(\log Y)} from the generated events.
  \item \code{pi_c_target}: requested censoring rate.
  \item \code{pi_c_observed}: realized censoring rate in the sample.
  \item \code{v}, \code{beta}: model parameters.
}
}
\description{
Generates survival data under a Cox proportional hazards model with a Weibull
baseline cumulative hazard \eqn{H_0(t) = (0.5 t)^v}. Event times are sampled via
inverse-transform:
\deqn{Y = H_0^{-1}(-\log U \cdot \exp(-\beta^T X)), \quad U \sim \mathrm{Unif}(0,1),}
where \eqn{H_0^{-1}(s) = 2 s^{1/v}} and covariates \eqn{X_j = 10 \cdot \mathrm{Bernoulli}(0.5)}.

Right censoring times are generated as \eqn{C_i = \exp(\mu + r_i)} with
\eqn{r_i \sim \mathcal{N}(0, \mathrm{sd}^2)}. By default, \code{sd} is taken to be
\eqn{\mathrm{sd}(\log Y)} and \code{mu} is calibrated so that the expected censoring
proportion equals \code{pi_c}. If \code{mu} and/or \code{sd} are supplied, calibration
is skipped appropriately:
\itemize{
  \item \strong{mu and sd provided:} use them as-is (no solving).
  \item \strong{sd provided only:} solve for \code{mu} using this \code{sd}.
  \item \strong{mu provided only:} estimate \eqn{\mathrm{sd}(\log Y)} and use the given \code{mu}.
  \item \strong{neither provided:} estimate \eqn{\mathrm{sd}(\log Y)} and solve for \code{mu}.
}
}
\examples{
# 1) Default: estimate sd=sd(logY), solve for mu to hit pi_c
set.seed(1)
d1 <- sim_cox_weibull_censored2(n = 500, pi_c = 0.30, v = 1.2, beta = c(0.4, -0.2))
attr(d1, "mu"); attr(d1, "sd_log"); attr(d1, "pi_c_observed")

# 2) Provide sd only: solve for mu using this sd
d2 <- sim_cox_weibull_censored2(n = 500, pi_c = 0.30, v = 1.2, beta = 0.5, sd = 0.8)

# 3) Provide mu only: use mu, estimate sd = sd(logY)
d3 <- sim_cox_weibull_censored2(n = 500, pi_c = 0.30, v = 1.2, beta = 0.5, mu = 1.5)

# 4) Provide both mu and sd: skip calibration entirely
d4 <- sim_cox_weibull_censored2(n = 500, pi_c = 0.30, v = 1.2, beta = 0.5, mu = 1.5, sd = 0.7)

}
